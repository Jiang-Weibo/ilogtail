# 说明文档

## 修改说明

针对第一次任务的反馈建议，主要对语法关键字和合法表达式进行了修改，并针对反馈中的提问给出了更多的例子和相关说明。
[项目链接](https://github.com/Jiang-Weibo/ilogtail/tree/main)  
代码均存放在'filter-parser-test'文件夹下，BashParser.cpp是代码实现; 为了方便把jsoncpp这个库放在了同一文件夹下; unit_test.cpp是单元测试代码; test.cpp允许自己输入一个表达式进行测试。  

``` bash
make unit_test #进行单元测试，测试结果存放在tests-records.txt里
make # 将BashParser, jsoncpp, test.cpp一起编译，允许自己输入一个表达式进行测试
make target #同上
```

## 语法来源

针对本次设计过滤表达式语法的任务，我在参考了SQL语句，Flink过滤语法以及其他常见表达式语法（如正则表达式）后，最终选择了类似Linux下Bash脚本的判断语句的语法。这种选择基于以下三点原因：  

1. ilogtail作为日志管理的开源框架，最常见的使用场景就是各种服务器后端，而编写Bash脚本是后端开发与运维人员非常熟悉的任务。因此使用Bash脚本的语法不会造成使用者额外的记忆负担，只需注意几点略微的**区别**就可以像写Bash脚本一样配置过滤器，非常方便。
2. Bash脚本的判断语句语法简单，容易上手，且语法本身的表达能力足以胜任目前过滤表达式的需求。
3. Bash脚本的基础判断语句语法简单，关键字少，实现起来非常方便且容易扩展。

***

## 语法关键字

* 精简了多条件的语法，删除了-a和-o这两个关键字，因为以目前的需求来看不存在多表达式求值后短路的情况

* 精简了语法之后，key不会出现二义性问题，而对于value如果出现了关键字则需要使用反斜杠'/'作为转义字符。

``` bash
[ # 用于标记表达式的开始
] # 用于标记表达式的结束
== # 用于标记一对key-value
$ # 用于标记key
&& # 用于表达两个表达式逻辑与的关系
|| # 用于标记两个表达式逻辑或的关系
! # 用于表达一对key-value不满足条件
```

***

## 合法及非法表达式举例

### 合法文法结构

形式化地说，一个合法的表达式应遵循以下文法：  

* *S -> &lt;Expr&gt;*  

* *&lt;Expr&gt; -> [ &lt;Stat&gt; ]  |  [ &lt;Stat&gt; ] &lt;Binary&gt; &lt;Expr&gt;*

* *&lt;Stat&gt; -> {!}&lt;Key&gt; == &lt;Value&gt; | {!}&lt;Key&gt; == &lt;Value&gt; &lt;Binary&gt; &lt;Stat&gt;*

* *&lt;Binary&gt; -> && | ||*

* *&lt;Key&gt; -> $id*

* *&lt;Value&gt; -> id*  

### 合法表达式举例

一句话讲，过滤表达式就是配置键值对之间与或非关系。  

1. 所有的键值对均以 *[ key == value ]* 的形式来配置。例如我们有名为student的key，我们希望过滤出value为Alice的一条记录，那么应该这么写

``` bash
[ $student == Alice ] #注意中间要有空格，而且key一定要有$打头。
```

2. 在一个中括号内，可以通过&&与||的关键字连接两条语句，分别表示两条语句的逻辑与跟逻辑或的关系。例如在上一个例子的基础上，我们还有一个名为class的key，我们希望过滤出value为freshman的记录，那么应该这么写  

``` bash
[ $student == Alice && $value == freshman ] #注意空格
```

3. 在两个表达式之间，我们要通过&&以及||来表示这两个表达式的逻辑与跟逻辑或的关系。继续之前的例子，现在我们希望让名为Bob的student也通过过滤选择，那么可以这么写  

``` bash
[ $student == Alice && $value == freshman ] || [ $student == Bob ] # ||之间可以没有空格
```

4. 逻辑非只能用于最靠近于它的一条语句的前面。例如我们想要过滤出除了student字段中除Bob以外的记录，那么可以这么写

``` bash
[ ! $student == Bob ] # !的后面可以没有空格
```

5. 如果键值对中的value以关键字**开头**则需要以反斜杠'\'开头作为转义字符，如果value中本身含有反斜杠则需要写成两个连续的反斜杠。

``` bash
[ $symbol == \[flag\] ] # key不会出现二义性问题所以不用添加反斜杠，该表达式等价于 symbol == [flag]
[ $exception == \\flag ] #该表达式等价于 exception == \flag
[ $other == Alice&&Bob ] #这里的&&不需要使用反斜杠转义，因为它不是value的开头字符，该表达式等价于 other == Alice&&Bob
[ $and == \&&id] #这里只需要对第一个&使用转义即可，该表达式等价于 and == &&id
[ $and == \&\&id] #该表达式合法，但会被解读为 and == &\&id
```

### 非法表达式举例

1. 最常见的错误就是缺少必要的空格，例如  

``` bash
[ $student==Alice ] #错误！我们无法提前知道变量student的存在，因此要加空格
```

2. key必须在==的前面（这个后面可以重新设计一下）。  

``` bash
[ Alice == $student ] #错误！但后面可以支持这种写法
```

3. 逻辑非只能用在语句（也就是被中括号括起来的那部分）里面。

``` bash
![ $student == Alice ] #错误！逻辑非!只能用于最靠近它的右侧的语句
```

4. 不支持多重嵌套。

``` bash
[ $student == Alice && [ $age == 22 || $height == 167 ] ] #错误！不支持多个表达式的内部嵌套
[ $student == Alice ] && [ $age == 22 || $height == 167 ] #正确
```

5. 反斜杠'\'后只能出现关键字(目前有[, ], =, $, &, |, !)和转义符'\'而不能出现其他字符，否则会报错。

``` bash
[ $student == \Alice ] #错误！反斜杠'\'后必须紧跟 [, ], =, $, &, |, ! 其中之一
```

### 与Bash语法的区别

1. Bash中支持以引号包裹住变量，本语法不支持。
2. Bash中的所有变量需要以$打头，而本语法中的$仅仅表示是kv对中的k。
3. 修改后，在一个表达式中可以出现 *[ expr1 && expr2 ]* 的合法表达式，在Bash中这是非法的。
4. Bash支持更丰富的条件比较，例如对数字可以比较大小 *(-gt, -lt, -eq )* ，对字符串可以比较是否为空 *(-z)* 等等，而本语法本质上只能判断两个字符串是否相等(使用 *==* 符号)。
5. Bash中存在很多特殊变量(内部变量和环境变量)，而本语法中的所有变量本质上都是一个由用户定义的字符串(以$开头)，不存在 \$#, \$\*, \$1 等特殊变量。

## 代码设计

整个表达式的解析分为**词法分析**、**语法分析**以及**语言转换**三个阶段。  

### 词法分析

在词法分析阶段，程序将从左到右顺序扫描并根据关键字生成token流，并准备传递到下一个阶段。

### 语法分析

在语法分析阶段，一般的做法是构建一颗抽象语法树AST再根据文法使用递归下降或LL(1)来解析这棵树。但是由于我们的表达式本来比较简单，而使用递归下降法生成AST时会因为优先级等因素比较复杂和繁琐，因此我打算只用递归下降法确定一个表达式是否合法。在确定表达式的合法性后直接将token流在经过简单的处理后变为一个前缀表达式，然后将该前缀表达式传递给最后一个阶段。

### 语言转换

再语言转换阶段，我们可以使用json库（任何一个json库都可以，也使用ilogtail目前所依赖的json库）将前缀表达式转化成相对应的符合当前要求的filter_expression.最后将这个filter_expression返回给调用者，目前这个filter_expression是一个Json::Value对象.

### 具体设计说明与类图

设计上，这三个阶段都由一个parser类负责，整个Parser类只会向外暴露出一个GetJson(str)的方法，该方法的参数只有一个，就是一个过滤表达式，而该方法的返回值是一个Json::Value对象，如果解析成功这个对象内部就有我们想要的json，否则是一个空对象，同时会输出一些错误信息。
